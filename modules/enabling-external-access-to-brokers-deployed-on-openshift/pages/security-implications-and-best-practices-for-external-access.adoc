= Securing External Access to AMQ Broker on OpenShift

:navtitle: External Access Security

This module delves into the critical security considerations and best practices when enabling external clients to connect to your Red Hat AMQ Broker instances deployed on OpenShift. Properly securing external access is paramount to protect your messaging infrastructure and the sensitive data it handles.

== Security Implications of External Access

When you expose your AMQ Broker to external networks, you introduce potential attack vectors and vulnerabilities that must be addressed. Understanding these implications is the first step towards building a robust security posture.

=== 1. Increased Attack Surface

Exposing broker listeners via OpenShift Routes or NodePorts expands the network surface accessible to external entities. This inherently increases the potential for malicious actors to discover and attempt to exploit vulnerabilities in your broker or the underlying OpenShift platform.

=== 2. Data Interception and Tampering

Without proper encryption, data transmitted between external clients and the broker over public or untrusted networks can be intercepted and read (eavesdropping) or even modified (tampering) by attackers. This compromises the confidentiality and integrity of your messages.

=== 3. Unauthorized Access and Abuse

If authentication and authorization mechanisms are weak or improperly configured, unauthorized users or applications could gain access to your broker. This could lead to:

*   **Data theft:** Accessing sensitive messages from queues or topics.
*   **Service disruption:** Maliciously deleting queues, messages, or reconfiguring the broker.
*   **Resource exhaustion:** Flooding the broker with messages or connection attempts, leading to Denial of Service (DoS).

=== 4. Exposure of Broker Internals

Misconfigured external access might inadvertently expose internal network details, broker version information, or other metadata that could aid an attacker in planning further attacks.

== Best Practices for Securing External Access

Implementing a layered security approach is crucial for protecting your AMQ Broker when enabling external access.

=== 1. Encrypting Connections with SSL/TLS

Encrypting client-broker communication is a fundamental security requirement. SSL/TLS (Transport Layer Security) ensures that data exchanged between the client and the broker remains confidential and tamper-proof.

OpenShift Routes can handle TLS termination, but for AMQ Broker, it's often preferred to use *passthrough* routes or re-encrypt routes to ensure end-to-end encryption from the client to the broker pod. The broker itself must be configured to use TLS listeners.

==== One-Way TLS vs. Two-Way TLS (Mutual TLS)

*   **One-Way TLS:** The client verifies the broker's identity using the broker's certificate. This ensures the client is connecting to the legitimate broker and encrypts the communication. The broker does not verify the client's identity at the TLS layer.
*   **Two-Way TLS (Mutual TLS - mTLS):** Both the client and the broker verify each other's identities using certificates. This provides a stronger level of authentication, as the broker will only allow connections from clients presenting a trusted certificate.

==== Configuring Clients for TLS

Clients connecting to a TLS-enabled broker listener must be configured with the necessary trust stores and, for two-way TLS, key stores.

*   **Trust Store (`client.ts`):** Contains the certificate of the Certificate Authority (CA) that signed the broker's certificate, or the broker's public certificate itself. This allows the client to verify the broker's identity.
*   **Key Store (`client.ks`):** Contains the client's private key and its corresponding certificate. This is required for two-way TLS, allowing the client to present its identity to the broker.

The provided context highlights how to configure different protocol clients for TLS.

===== OpenWire Client with Two-Way TLS

For an external OpenWire client using two-way TLS, the connection URL must specify the `ssl://` protocol and the port (typically 443 for external routes). Additionally, Java Virtual Machine (JVM) flags are used to provide the paths and passwords for the client's key store and trust store.

[source,bash]
----
# Client connection URL
ssl://my-broker-deployment-0-svc-rte-my-openshift-project.my-openshift-domain:443

# JVM flags for client-side key and trust store configuration
-Djavax.net.ssl.keyStore=~/client.ks -Djavax.net.ssl.keyStorePassword=<key_store_password> \
-Djavax.net.ssl.trustStore=~/client.ts -Djavax.net.ssl.trustStorePassword=<trust_store_password>
----

*   Replace `my-broker-deployment-0-svc-rte-my-openshift-project.my-openshift-domain` with the actual route hostname.
*   Replace `<key_store_password>` and `<trust_store_password>` with your actual passwords.

===== AMQP Client with One-Way TLS

For an external AMQP client using one-way TLS, the connection URL uses `amqps://` and includes parameters for the trust store. The `transport.verifyHost=true` parameter is crucial for host name verification, preventing man-in-the-middle attacks.

[source,url]
----
amqps://my-broker-deployment-0-svc-rte-my-openshift-project.my-openshift-domain:443?
transport.verifyHost=true&transport.trustStoreLocation=~/client.ts&transport.trustStorePassword=<trust_store_password>
----

*   Replace `my-broker-deployment-0-svc-rte-my-openshift-project.my-openshift-domain` with the actual route hostname.
*   Replace `<trust_store_password>` with your actual password.

===== AMQP Client with Two-Way TLS

For an external AMQP client using two-way TLS, both the key store and trust store parameters are included in the connection URL.

[source,url]
----
amqps://my-broker-deployment-0-svc-rte-my-openshift-project.my-openshift-domain:443?
transport.verifyHost=true&transport.keyStoreLocation=~/client.ks&transport.keyStorePassword=<key_store_password>&transport.trustStoreLocation=~/client.ts&transport.trustStorePassword=<trust_store_password>
----

*   Replace `my-broker-deployment-0-svc-rte-my-openshift-project.my-openshift-domain` with the actual route hostname.
*   Replace `<key_store_password>` and `<trust_store_password>` with your actual passwords.

=== 2. Strong Authentication and Authorization (RBAC)

Beyond TLS encryption, strong authentication and granular authorization are critical to control who can connect to your broker and what actions they can perform.

*   **AMQ Broker's Internal Security:** AMQ Broker provides its own robust security mechanisms, allowing you to define users, roles, and fine-grained permissions for queues, topics, and broker operations.
*   **Integrating with OpenShift Authentication:** For applications deployed on OpenShift, you can leverage OpenShift's built-in authentication mechanisms (e.g., service accounts, OAuth with Keycloak) to provide identities to your messaging clients.
*   **External Identity Providers (IDPs):** For external clients, integrating with enterprise-grade IDPs like LDAP, Active Directory, or Keycloak allows you to centralize user management and enforce consistent access policies. AMQ Broker can be configured to delegate authentication to these external systems and map external roles to internal broker roles.

=== 3. Network Segmentation and Firewalls

Utilize OpenShift NetworkPolicies to restrict network traffic to and from your AMQ Broker pods. This allows you to:

*   **Isolate brokers:** Ensure only authorized applications or external ingress controllers can reach the broker's listeners.
*   **Control egress:** Limit what external resources your broker can connect to, if any.

For external access, ensure that any external firewalls or cloud security groups are configured to only allow traffic on the specific ports and protocols required for your broker (e.g., 443 for HTTPS/TLS).

=== 4. Secure OpenShift Routes and Ingress

When exposing AMQ Broker via OpenShift Routes or an Ingress controller, configure them securely:

*   **TLS Termination:** Always enable TLS on your routes (`https://`). For AMQ Broker, prefer `passthrough` routes to maintain end-to-end encryption to the broker pod, or use `re-encrypt` routes if the broker is configured for HTTPS. Avoid `edge` termination unless you have specific reasons and understand the implications (data is unencrypted between the router and the broker pod).
*   **Hostnames:** Use specific hostnames rather than wildcards, where possible, to reduce exposure.
*   **Load Balancing:** If you have multiple broker pods behind a route, clients might load balance connections. If you prefer clients *not* to use topology information for load balancing, you can configure the client connection URL as specified in the context:
    *   For Core protocol clients, set `useTopologyForLoadBalancing=false`.
    *   For other clients, explicitly list each broker's route hostname in the connection URL to ensure explicit failover rather than load balancing.

=== 5. Principle of Least Privilege

Grant only the minimum necessary permissions to users and applications accessing the broker.

*   **Client Permissions:** A client application publishing messages to a specific topic should only have permission to publish to that topic, not to administer the broker or consume from unrelated queues.
*   **Operator Permissions:** The AMQ Broker Operator should run with appropriate service account permissions, following OpenShift's security best practices.

=== 6. Monitoring and Logging

Implement comprehensive monitoring and logging for your AMQ Broker and OpenShift environment.

*   **Broker Logs:** Monitor broker logs for failed connection attempts, authentication failures, and suspicious activities.
*   **OpenShift Audit Logs:** Leverage OpenShift's audit logging to track API calls related to routes, services, and broker Custom Resources.
*   **Network Activity:** Monitor network traffic to identify unusual patterns or attempted intrusions.

=== 7. Regular Security Audits and Updates

*   **Patching:** Keep your AMQ Broker images, OpenShift platform, and client libraries updated to the latest stable versions to benefit from security fixes.
*   **Audits:** Periodically review your security configurations, network policies, and access controls to ensure they align with your organization's security policies and best practices.

== Hands-on Activity: Configuring External Client with One-Way TLS

In this activity, you will simulate connecting an external client to an AMQ Broker instance exposed via an OpenShift Route with one-way TLS enabled. This assumes you have an AMQ Broker already deployed on OpenShift with a TLS listener and an HTTPS/passthrough route, and have obtained the necessary broker certificate or CA certificate.

[NOTE]
This activity focuses on the *client-side configuration* based on the provided context. Setting up the broker's TLS listener and OpenShift Route is outside the immediate scope of this topic but is a prerequisite for a fully functional setup.

=== Prerequisites

*   An OpenShift cluster with the AMQ Broker Operator installed.
*   An AMQ Broker instance deployed, configured with a TLS listener (e.g., on port 61617) and accessible via an OpenShift `passthrough` or `re-encrypt` route (e.g., exposed on port 443).
*   The hostname of the OpenShift Route (e.g., `my-broker-deployment-0-svc-rte-my-openshift-project.my-openshift-domain`).
*   The public certificate of your AMQ Broker or the CA certificate that signed it. Save this certificate to a file, for example, `broker.crt`.
*   Java Development Kit (JDK) installed on your client machine.
*   Apache ActiveMQ Artemis client libraries or Apache Qpid JMS client libraries for AMQP.

=== Steps

==== 1. Prepare the Client Trust Store

You need to import the broker's certificate into a Java KeyStore (JKS) file that will serve as your client's trust store.

. Create a new trust store file:
+
[source,bash]
----
keytool -import -alias broker-cert -file broker.crt -keystore client.ts -storepass <trust_store_password> -noprompt
----
+
*   Replace `broker.crt` with the path to your broker's certificate file.
*   Replace `<trust_store_password>` with a strong password for your trust store. Remember this password for the next steps.

==== 2. Develop a Simple AMQP Client (Java Example)

Create a simple Java AMQP client application that will connect to the broker. This example uses the Qpid JMS client.

. Create a file named `AmqpTlsProducer.java` with the following content:
+
[source,java]
----
import javax.jms.*;
import org.apache.qpid.jms.JmsConnectionFactory;

public class AmqpTlsProducer {

    public static void main(String[] args) throws JMSException {
        // Replace with your broker's route hostname and port (e.g., 443 for HTTPS routes)
        String BROKER_HOSTNAME = "my-broker-deployment-0-svc-rte-my-openshift-project.my-openshift-domain";
        String TRUST_STORE_PATH = System.getProperty("user.home") + "/client.ts"; // Path to your client.ts
        String TRUST_STORE_PASSWORD = "<trust_store_password>"; // Your trust store password

        // AMQP 1.0 connection URL with one-way TLS configuration
        String connectionUri = String.format("amqps://%s:443?transport.verifyHost=true&transport.trustStoreLocation=%s&transport.trustStorePassword=%s",
                                            BROKER_HOSTNAME, TRUST_STORE_PATH, TRUST_STORE_PASSWORD);

        ConnectionFactory connectionFactory = new JmsConnectionFactory(connectionUri);
        Connection connection = null;
        Session session = null;

        try {
            connection = connectionFactory.createConnection();
            connection.start();
            session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
            Destination destination = session.createQueue("mySecureQueue");
            MessageProducer producer = session.createProducer(destination);

            TextMessage message = session.createTextMessage("Hello from secured AMQP client!");
            producer.send(message);
            System.out.println("Sent message: " + message.getText());

        } catch (Exception e) {
            System.err.println("Error connecting or sending message: " + e.getMessage());
            e.printStackTrace();
        } finally {
            if (session != null) session.close();
            if (connection != null) connection.close();
        }
    }
}
----
+
*   Replace `my-broker-deployment-0-svc-rte-my-openshift-project.my-openshift-domain` with your actual broker route hostname.
*   Replace `<trust_store_password>` with the password you set in the previous step.

==== 3. Compile and Run the Client

. Download the Qpid JMS client JARs. You can usually find them in Maven Central or include them via a `pom.xml` if using Maven. For simplicity, download `qpid-jms-client-<version>.jar` and its dependencies (e.g., `slf4j-api`, `proton-j`).
. Compile the Java client:
+
[source,bash]
----
javac -cp ".:/path/to/qpid-jms-client-<version>.jar:/path/to/slf4j-api-<version>.jar" AmqpTlsProducer.java
----
+
*   Adjust the classpath (`-cp`) to include all necessary Qpid JMS client JARs and their dependencies.
. Run the client:
+
[source,bash]
----
java -cp ".:/path/to/qpid-jms-client-<version>.jar:/path/to/slf4j-api-<version>.jar" AmqpTlsProducer
----
+
If successful, you should see output indicating the message was sent, and the connection will be established over TLS. You can verify the message on your broker's management console.

This hands-on activity demonstrates how to configure a client to leverage one-way TLS for secure communication, a critical step in enabling external access securely. For two-way TLS, you would additionally generate a client key pair, create a client key store, and configure the client connection URL with `transport.keyStoreLocation` and `transport.keyStorePassword` parameters, as shown in the examples provided in the context.
